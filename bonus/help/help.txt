# To do
k3d cluster --k3s-arg "--disable=traefik@server:0"

Or find another solution cleaner 

# On install on yaml file 
prometheus:
    install: false

gitlab-runner:
    install: false

Install gitlab 

Helm gestionnaire de packets : 

# Install GitLab :
The GitLab Helm chart uses the Cloud Native GitLab (CNG) 
container images to deploy GitLab. Besides the CNG images 
for GitLab itself, the default configuration uses images 
published by third parties (for example, Bitnami) to deploy 
PostgreSQL, Redis, and MinIO to simplify non-production deployments.

# Prerequisites

Script qui install ca 
- kubectl
- helm 
- PostgreSQL
- Redis (in cluster)
- Gitaly (in cluster)

# 1. Docker (si pas déjà installé)
# 2. K3d
# 3. kubectl
# 4. Helm (indispensable pour GitLab)
# 5. GitLab Helm Chart (officiel)


✅ Créer le cluster K3d
✅ Installer GitLab
✅ Configurer Argo CD avec GitLab
✅ Cleanup

# Monitoring the deployment
helm status gitlab 

# Initial login 
kubectl get secret <name>-gitlab-initial-root-password -ojsonpath='{.data.password}' | base64 --decode ; echo

# Argo cd 
argocd repo add https://github.com/argoproj/argocd-example-apps --username <username> --password <password>

# To have an example of values.yaml for gitlab 
helm show values gitlab/gitlab > tmp_values.yaml

helm uninstall gitlab -n gitlab 2>/dev/null || true
kubectl delete namespace gitlab 2>/dev/null || true
sleep 5
./install_gitlab.sh


# install gitlab 
helm uninstall gitlab -n gitlab 2>/dev/null || true
kubectl delete namespace gitlab 2>/dev/null || true
sleep 5

Launch script 
wait pods to be ready 
kubectl -n gitlab get pods -w



#1- Install 

# 2- setup_cluster 
Traefik is a ingress Controller. 


Next steps:
1. Add this to your /etc/hosts file:
   127.0.0.1 gitlab.local

2. Access GitLab at: http://gitlab.gitlab.local

3. Get initial root password:
   kubectl get secret -n gitlab gitlab-gitlab-initial-root-password -ojsonpath='{.data.password}' | base64 --decode ; echo

4. Monitor deployment:
   kubectl -n gitlab get pods
   helm status gitlab -n gitlab


echo "127.0.0.1 gitlab.gitlab.local" | sudo tee -a /etc/hosts
curl http://gitlab.gitlab.local

Pour installer gitlab souci de mémoire :
sudo sync
sudo sysctl -w vm.drop_caches=3

==> a faire : ./setup_argocd_gitlab.sh

===============================================


clean apres setup_cluster :
k3d cluster list
k3d cluster stop iot-cluster
k3d cluster start iot-cluster

===============================================
Gitlab part 

Une release dans Helm est une instance d'un chart déployée dans Kubernetes.
Analogie :
Chart Helm = recette de cuisine
Release = le plat que vous préparez à partir de la recette
Concrètement :
Un chart GitLab contient tous les fichiers nécessaires pour installer GitLab (templates Kubernetes, configurations, dépendances).

Une instance dans ce cas est une copie en fonctionnement d'une application.
Analogie du restaurant :

Chart GitLab = le plan/la recette pour ouvrir un restaurant GitLab
Instance GitLab = un restaurant GitLab réel, avec ses cuisines, ses serveurs, ses clients
Dans votre cluster :

Quand vous faites helm install gitlab gitlab/gitlab, vous créez :

1 instance de GitLab avec ses pods (serveur web, base de données, cache, etc.)
Cette instance fonctionne de manière indépendante
Elle a ses propres données, configurations, utilisateurs

Analogue concret :
Concept	Analogie
Kubernetes	Un datacenter avec plusieurs serveurs
Helm	Un magasin de logiciels pré-packagés
Chart GitLab	La recette/le paquet GitLab du magasin
helm install	"Je prends le paquet GitLab et l'installe dans mon datacenter"

Pourquoi passer par Helm au lieu d'installer Gitlab directement ?
Si l'on veut installer a la main on va passer par des fichiers yaml qu'on doit modifier a la main
   - Beaucoup de fichiers yaml difficiles a gérer 
   - Erreurs faciles
   - Duplication massive de code
   - Interconnexions complexes entre les services
   - Maintenance difficile 
Avec Helm on peut le faire en une seule commande :
helm install gitlab gitlab/gitlab --set global.hosts.domain="local"

Analogie
Sans Helm	Avec Helm
Construire une maison	Faire tous les plans, acheter tous les matériaux, construire soi-même	Acheter un kit prêt à construire
Installer un logiciel	Écrire la config, installer les dépendances	Apt install / brew install
Kubernetes	Écrire 500 lignes YAML	Une ligne Helm

Avantages de Helm
1. Abstraction
On n'a pas besoin de connaître tous les détails internes
Juste donner les paramètres importants (--set)
2. Réutilisabilité
Le chart GitLab a déjà été testé par la communauté
Utiliser la même configuration que des milliers d'autres
3. Templating
Helm remplace automatiquement les variables
Une même chart = multiples environnements (prod, staging, dev)
4. Gestion des versions
helm upgrade gitlab gitlab/gitlab --version 7.0.0


helm show values gitlab/gitlab

--set gitlab-runner.install=false
# Question : "Ai-je besoin de CI/CD ?"
# Réponse : Non (apprentissage) → false ✅

--set prometheus.install=false
# Question : "Ai-je besoin de monitoring ?"
# Réponse : Non → false 

--set certmanager.enabled=false
# Question : "Ai-je besoin de certificats SSL ?"
# Réponse : Non (dev local) → false ✅

--set gitaly.persistence.enabled=false
# Question : "Ai-je besoin de persistance ?"
# Réponse : Non (données éphémères) → false



    helm install "$RELEASE_NAME" gitlab/gitlab \
    # Créer et utilise gitlab pour utiliser des ressources => OBLIGATOIRE
        --namespace "$NAMESPACE" \
   # Essentiel pour avoir un acces web ==> OBLIGATOIRE
        --set global.hosts.domain="$DOMAIN" \
   # Defini la version CE community edition gratuit => OBLIGATOIRE
        --set global.edition=ce \
   # Certificats SSL non essentiel en local => FACULTATIF
        --set certmanager.enabled=false \
   # Desactive les certificats ingress pour du local => FACULTATIF
        --set global.ingress.configureCertmanager=false \
   # Proxy d'entrée pour les requettes http => OBLIGATOIRE
        --set global.ingress.provider=nginx \
   # Db indispensable pour Gitlab => OBLIGATOIRE
        --set postgresql.install=true \
   # Memoire cash pour performance => OBLIGATOIRE
        --set redis.install=true \
   # Données persistantes => FACULTATIF
        --set gitaly.persistence.enabled=false \
   # Pipeline => FACULTATIF
        --set gitlab-runner.install=false \
   # Monitoring => FACULTATIF
        --set prometheus.install=false \
   # Desactive la gestion de certificats => FACULTATIF
        --set installCertmanager=false \
   # Si on ne fait pas ca gitlap prend toutes les ressources => OBLIGATOIRE
        --set gitlab.webservice.resources.requests.memory=512Mi \
        --set gitlab.webservice.resources.requests.cpu=100m \
   # Taches insincrones => OBLIGATOIRE
   # On réduit l'utilisation des taches asyncrones vu le besoin du sujet 
        --set gitlab.sidekiq.resources.requests.memory=256Mi \
        --set gitlab.sidekiq.resources.requests.cpu=50m \
   # Nettoyer le filtrage 
        2>&1 | grep -v "deprecated"


Comment passer du values.yaml a set ? 

# values.yaml
global:
  hosts:
    domain: local

Devient :
--set global.hosts.domain="local"

chaque ":"devient un "."

ON doit garder juste 

============================
P3/
kubectl apply -f deployment.yaml


============================

bonus/
Comparaison des 2 approches
Aspect              | Ancienne (API REST)                   |	Nouvelle (Git protocol)
Endpoint	          | https://gitlab.local/api/v4/projects	|    https://gitlab.local/root/iot_lciullo.git
Authentification    | Token requis (401)	               | HTTP Basic Auth (accepté)
Création du projet	| Manuelle via API	               | Automatique au 1er push
Complexité          | Besoin de token + API call	     | Juste git push --mirror
Erreur reçue	     | 401 Unauthorized	               | Aucune (ça marche direct)


ingress root 

kind: ingress root 


Internet (votre machine)
    ↓
Nginx Ingress Controller (port 80/443)
    ↓
Service GitLab (ClusterIP interne)
    ↓
Pod GitLab


===========================
3- make setup-gitlab
Installer gitlab prend plusieurs minutes 


==================================

# Acceder au shell du cluster :
# Voir les pods disponibles
kubectl get pods -n gitlab

Parmi cette liste pods principale a utiliser est :
gitlab-webservice-default
Note : il y en a deux donc on peut aussi bien aller dans l'un ou dans l'autre 

# Recuperer l'ip 
kubectl get svc -n gitlab gitlab-webservice-default
10.43.74.61 

# Recuperer juste l'adresse ip 
kubectl get svc -n gitlab gitlab-webservice-default -o jsonpath='{.spec.clusterIP}'

==========================

To do 

Automatiser l'acces avec un token => essayer de le faire en ligne de commandes 

Voir pour mettre le repo en privé => logiquement ca 
fonctionne donc tester lundi avec le repo privé 

Pouvoir push en ligne de commandes sur le repo gitlab en privé et non via l'interface 

http://gitlab-webservice-default.gitlab.svc.cluster.local:8181/root/iot-lciullo.git

Revoir la notion de repo miroir 

# A rajouter dans le makefile 

Pour clean 
kubectl delete application -n argocd wil-playground-app
kubectl delete -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml --ignore-not-found=true
kubectl delete namespace argocd --ignore-not-found=true
kubectl delete namespace dev --ignore-not-found=true 
